{"name":"Gzzopt","tagline":"Another option parser writen in C++, I hated the other examples I've seen so I made this it's small but powerful","body":"This is the gzzopt option parsing library\r\n=========================================\r\n\r\nAuthor: Francis Grizzly Smit\r\n----------------------------\r\n\r\n## Contents\r\n\r\n- [Introduction](#introduction)\r\n- [example.cpp and example0.cpp](#example-and-example0)\r\n- [calc.cpp and cacl2.cpp](#calc-and-calc2)\r\n- [count.cpp](#count)\r\n- [A brief explanation of the format of a program using gxxopts](#a-brief-explanation-of-the-format-of-a-program-using-gxxopts)\r\n- [Making the Library a Library](#making-the-library-a-library)\r\n- [empty.cpp](#empty)\r\n- [bad.cpp](#bad)\r\n- [vect.cpp](#vect)\r\n- [See Also](#see-also)\r\n\r\n<!-- end toc -->\r\n\r\n\r\n\r\n### Introduction ###\r\n\r\nThe library is contained in the files *gzzopt.hpp* and *gzzopt.cpp*, (see below for how to create libgzzopt.a and libgzzopt.so) there are also 8 example programs *calc, calc2, count, bad, vect, empty, example0,* and *example*.\r\n\r\n### Example and Example0 ###\r\n\r\n*example* is a complex example of just what complex a set of command lines you can achieve; *example0* shows how you can go wrong the gotcha is that *example0* tries to have the command line:\r\n<pre>\r\n...\r\n./example0 install &lt;pacakage&gt;...\r\n./example0 install info &lt;pacakage&gt;...\r\n</pre>\r\n\r\nthe problem is *install* shadows *info* and info is treated as a package argument where as *example* uses: \r\n<pre>\r\n...\r\n./example install &lt;pacakage&gt;...\r\n./example info &lt;pacakage&gt;...\r\n</pre>\r\n\r\nThis works fine, try each.\r\n\r\n### Calc and Calc2 ###\r\n\r\n*calc* and *calc2* are the same as each other, except for how there arguments are specified, to wit:\r\n<pre>\r\n21:26:00 grizzlysmit@rakbat:~/Projects/C++/gzzoption$ ./calc --help\r\n./calc --help|-h\r\n./calc [--help|-h] [--verbose|-v] [--quiet|-q] add|sub|mult|div|pow &lt;x&gt; &lt;y&gt;\r\n\r\n\r\nwhere:\r\n\t--help|-h            : show this help\r\n\t                       \r\n\t[--help|-h]          : show this help\r\n\t[--verbose|-v]       : proceed verbosely\r\n\t[--quiet|-q]         : proceed quietly\r\n\tadd|sub|mult|div|pow : apply op to x and y\r\n\t&lt;x&gt;                  : a double value\r\n\t&lt;y&gt;                  : a double value\r\n\t                       \r\n\r\n21:29:41 grizzlysmit@rakbat:~/Projects/C++/gzzoption$ ./calc2 --help\r\n./calc2 [--help|-h]\r\n./calc2 [--verbose|-v] [--quiet|-q] add &lt;x&gt; &lt;y&gt;\r\n./calc2 [--verbose|-v] [--quiet|-q] sub &lt;x&gt; &lt;y&gt;\r\n./calc2 [--verbose|-v] [--quiet|-q] mult &lt;x&gt; &lt;y&gt;\r\n./calc2 [--verbose|-v] [--quiet|-q] div &lt;x&gt; &lt;y&gt;\r\n./calc2 [--verbose|-v] [--quiet|-q] pow &lt;x&gt; &lt;y&gt;\r\n\r\n\r\nwhere:\r\n\t[--help|-h]    : show this help\r\n\t                 \r\n\t[--verbose|-v] : proceed verbosely\r\n\t[--quiet|-q]   : proceed quietly\r\n\tadd            : apply op to x and y\r\n\t&lt;x&gt;            : a double value\r\n\t&lt;y&gt;            : a double value\r\n\t                 \r\n\tsub            : apply op to x and y\r\n\t                 \r\n\tmult           : apply op to x and y\r\n\t                 \r\n\tdiv            : apply op to x and y\r\n\t                 \r\n\tpow            : apply op to x and y\r\n\t                 \r\n</pre>\r\n\r\nAs you can see *calc* uses one argument spec *add|sub|mult|div|pow* where as *calc2* does the same thing using one command line per *add*, through to *pow*, as a result to avoid duplicate lines in the usage message; I used *p.set_compact(true);* in *calc2.cpp*.\r\nAll of the programs correspond to a *.cpp* file see the *Makefile* for details.\r\n\r\n### Count ###\r\n\r\n*count* shows a simple example of an incrementing integer option see *count.cpp*, this is done with an incrementing function, this is the best solution for this problem, I could do it by adding still more helper classes and special constructors and it gets progressively more ugly, so I bailed for something which will have fewer problems, and I think is an eloquent solution. see code below, or read *count.cpp*:\r\n\r\n<pre>\r\n   <code>\r\n#include \"gzzopt.hpp\"\r\n#include &lt;string&gt;\r\n\r\n\r\nint main(int argc, char* argv[]){\r\n    using namespace gzzopts;\r\n    int cnt = 0;\r\n    bool help = false;\r\n    std::string s;\r\n\r\n    Opts opt{OptionSpec(help, \"show this help\", \"help\", 'h'),\r\n              OptionSpec([&cnt]() -&gt; bool { return ++cnt; },\r\n                      \"increment the number of times to repeat\",\r\n                                  \"count\", 'c' ).set_multi(true), \r\n              strvalue(s, \"a string\", \"s\").set_manditory(true),\r\n            };\r\n\r\n    OptionParser p(argc, argv, opt);\r\n    // parse away //\r\n    if(!p.parse()){\r\n        p.fullusage();\r\n        return 1;\r\n    }\r\n    /////////////////////////////////////////////////////////////\r\n    //                                                         //\r\n    //             Use the variables that where set            //\r\n    //                                                         //\r\n    /////////////////////////////////////////////////////////////\r\n    if(help){\r\n        p.fullusage();\r\n        return 0;\r\n    }\r\n\r\n    for(int i = 0; i &lt; cnt; i++) std::cout &lt;&lt; '`' &lt;&lt; s &lt;&lt; \"' \";\r\n    std::cout &lt;&lt; std::endl;\r\n    return 0;\r\n}\r\n   </code>\r\n</pre>\r\n\r\n###### NB #######\r\nHave to use *strvalue* to allow arbitary strings, should just been a variant of *positional* but my compiler goes to the **template** version instead. :P\r\n\r\n\r\n### A brief explanation of the format of a program using gxxopts ###\r\n\r\nThe format of a program is as follows in <code>main(int argc, char \\*argv[])</code> or similar, define one or more Opt objects, the elements of the Opt object are OptionSpec objects, these can be entered directly or via the convenience functions *positionnal* and *literal* which produce OptionSpec objects with extra options turned on a *positional* is just a positional argument, and a *literal* is a literal string to expect, in addition OptionSpec has a initializer\\_list constructor <code>OptionSpec(std::initializer\\_list&lt;Opts\\*&gt; opts)</code> which take a list of pointers to Opt objects (had to be pointers as Opts is an incomplete type at the time) so you can produce tree like structures. The constructor for Opt itself is a initializer\\_list <code>Opts(std::initializer\\_list&lt;OptionSpec&gt; lst)</code> so you can specify arbitrarily many elements.\r\n\r\nThe OptionSpec elements are of the form variable/setter function, description, a long opt name and an optional short opt char, and some optional boolean parameters to set things like positional multi etc use the convenience functions instead there are also setter functions that can be chained, these all take a single bool parameter and set the field their name suggests.\r\n\r\nThen when you have combined all this into one Opt object see *calc.cpp* and *call2.cpp*; construct a OptionParser object as follows <code>OptionParser p(argc, argv, opt);</code> then you can set a few parameters on the OptionParser object or not; then call p.parse(), this will return true on a error free run and false of error; then if parse returned true just use the variables that where set, the variables can be std::list&lt;T&gt; and std::vector&lt;T&gt; types as well so you can have slurpy arrays ala perl6 too; bellow is some sample code to illustrate:\r\n\r\n<pre>\r\n   <code>\r\n#include \"gzzopt.hpp\"\r\n#include &lt;string&gt;\r\n#include &lt;cmath&gt;\r\n\r\nenum class Opp  { none, add, sub, mult, div, pow };\r\n\r\n...\r\n\r\nint main(int argc, char *argv[]){\r\n    using namespace gzzopts;\r\n    double x, y;\r\n    Opp opp = Opp::none;\r\n    bool quiet = true, help = false;\r\n    function_str verb = [&quiet](const std::string& val) -> bool\r\n                                                { quiet = false; return !quiet; };\r\n    Opts opt1{OptionSpec(help, \"show this help\", \"help\", 'h'),\r\n                      OptionSpec(verb, \"proceed verbosely\", \"verbose\", 'v' ), \r\n                      OptionSpec([&quiet](const std::string& val) -> bool\r\n                              { return quiet = true; },\r\n                                           \"proceed quietly\", \"quiet\", 'q' ), \r\n                      literal([&opp](const std::string& n) -> bool\r\n                              { return set_opp(opp, n); },\r\n                                   \"apply op to x and y\",\r\n                                   \"add|sub|mult|div|pow\").set_no_more_opts(true),\r\n                      positional(x, \"a double value\", \"x\").set_manditory(true),\r\n                      positional(y, \"a double value\", \"y\").set_manditory(true),\r\n                    };\r\n   Opts opt{\r\n                      OptionSpec{&opt1, },\r\n                      OptionSpec(help, \"show this help\",\r\n                              \"help\", 'h').set_manditory(true).set_cut(true),\r\n           };\r\n   \r\n    OptionParser p(argc, argv, opt);\r\n    // parse away //\r\n    if(!p.parse()){\r\n        p.fullusage();\r\n        return 1;\r\n    }\r\n    /////////////////////////////////////////////////////////////\r\n    //             Use the variables that where set            //\r\n    /////////////////////////////////////////////////////////////\r\n    if(help){\r\n        p.fullusage();\r\n        return 0;\r\n    }\r\n    switch(opp){\r\n        case(Opp::none):\r\n            std::cout &lt;&lt; \"nothing to do\" &lt;&lt; std::endl;\r\n            break;\r\n        case(Opp::add):\r\n            if(!quiet) std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; \" == \";\r\n            std::cout &lt;&lt; (x + y) &lt;&lt; std::endl;\r\n            break;\r\n        case(Opp::sub):\r\n            if(!quiet) std::cout &lt;&lt; x &lt;&lt; \" - \" &lt;&lt; y &lt;&lt; \" == \";\r\n            std::cout &lt;&lt; (x - y) &lt;&lt; std::endl;\r\n            break;\r\n        case(Opp::mult):\r\n            if(!quiet) std::cout &lt;&lt; x &lt;&lt; \" * \" &lt;&lt; y &lt;&lt; \" == \";\r\n            std::cout &lt;&lt; (x * y) &lt;&lt; std::endl;\r\n            break;\r\n        case(Opp::div):\r\n            if(!quiet) std::cout &lt;&lt; x &lt;&lt; \" / \" &lt;&lt; y &lt;&lt; \" == \";\r\n            std::cout &lt;&lt; (x / y) &lt;&lt; std::endl;\r\n            break;\r\n        case(Opp::pow):\r\n            if(!quiet) std::cout &lt;&lt; x &lt;&lt; \"^\" &lt;&lt; y &lt;&lt; \" == \";\r\n            std::cout &lt;&lt; std::pow(x, y) &lt;&lt; std::endl;\r\n            break;\r\n        default:\r\n            std::cerr &lt;&lt; \"how in heavens name did I get here\" &lt;&lt; std::endl;\r\n            return 1;\r\n    }\r\n    return 0;\r\n}\r\n   </code>\r\n</pre>\r\n\r\n\r\n\r\n\r\n\r\n### Making the Library a Library ###\r\n\r\nTo make the library a library on Linux  do this \r\n<pre>\r\n   <code>g++ -shared -fPIC -o libgzzopt.so gzzopt.o</code> \r\n</pre>\r\n\r\nI shall look at putting this in the make file when I learn to do plaform specific stuff in a make file.\r\n\r\nTo make a statically linked library of it under Linux etc al do this\r\n<pre>\r\n   <code>\r\n   ar -cvq libgzzopt.a gzzopt.o\r\n   </code>\r\n</pre>\r\n\r\n#### NB ####\r\nThe make file **Makefile** now makes the libraries, for you. and installs them.\r\n\r\n### Empty ###\r\nThe **empty.cpp** program shows how to have a program that allows an empty argument set (most of the others here delibrately mmake that an error).\r\n\r\n### Bad ###\r\nThe program bad **bad.cpp** is an example of a bad option to wit a ? for the short option this is picked up by the good() method.\r\n\r\n### Vect ###\r\nThe **vect.cpp** program is just the **example.cpp** reworked to use **StrVect** i.e. *string vector vect* in place of the *string list l*.\r\n\r\n### See Also: ###\r\n\r\n[calc.cpp and cacl2.cpp](#calc-and-calc2) for a full example; and [example.cpp](#example-and-example0) for an example of how convoluted you can get. And [example0.cpp](#example-and-example0) for an example of a flawed spec reread above for why it's flawed. Also [count.cpp](#count), and [empty.cpp](#empty) and fianlly [bad.cpp](#bad) for an exaple of catching a bad option spec, note this only catches bad char specs not other errors.\r\n\r\n\r\n#### NB ####\r\nThis code was compiled with the -std=c++1y option to the g++ compiler as I use some of the more recent features of the C++ Programming language.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}